"""
Revised syn_seq.py

This module implements a sequential synthesizer (Syn_Seq) that fits each column 
of the data (following an ordering provided in syn_order) one by one.
It supports columns with special values. For such columns, during fitting the 
model only sees rows with numeric (non‐special) values. At generation time, the 
pre‐generated categorical (“_cat”) column (injected by the preprocessor) is used 
to decide which rows should be generated by the fitted model (when _cat equals "NUMERIC")
and which rows should directly receive the special value.
"""

from typing import Any, Dict, List, Optional, Tuple
import numpy as np
import pandas as pd

# Import column-fitting and generation functions for various methods.
from synthcity.plugins.core.models.syn_seq.methods import (
    syn_cart, generate_cart,
    syn_ctree, generate_ctree,
    syn_logreg, generate_logreg,
    syn_norm, generate_norm,
    syn_pmm, generate_pmm,
    syn_polyreg, generate_polyreg,
    syn_rf, generate_rf,
    syn_lognorm, generate_lognorm,
    syn_random, generate_random,
    syn_swr, generate_swr,
)

# Map method names to (fitting function, generation function)
METHOD_MAP: Dict[str, Tuple[Any, Any]] = {
    "cart": (syn_cart, generate_cart),
    "ctree": (syn_ctree, generate_ctree),
    "logreg": (syn_logreg, generate_logreg),
    "norm": (syn_norm, generate_norm),
    "pmm": (syn_pmm, generate_pmm),
    "polyreg": (syn_polyreg, generate_polyreg),
    "rf": (syn_rf, generate_rf),
    "lognorm": (syn_lognorm, generate_lognorm),
    "random": (syn_random, generate_random),
    "swr": (syn_swr, generate_swr),
}


class Syn_Seq:
    def __init__(
        self,
        random_state: int = 0,
        strict: bool = True,
        sampling_patience: int = 100
    ):
        """
        Args:
            random_state: Random seed.
            strict: (Unused now; rule‐checking is handled later.)
            sampling_patience: (Unused now.)
        """
        self.random_state = random_state
        self.strict = strict
        self.sampling_patience = sampling_patience

        # special_values: mapping base column name -> list of special values (e.g. {"capital-gain": [0]})
        self.special_values: Dict[str, List[Any]] = {}
        self._model_trained = False

        self._syn_order: List[str] = []       # synthesis order of columns
        self._method_map: Dict[str, str] = {}   # method for each column (e.g. "cart")
        self._varsel: Dict[str, List[str]] = {} # predictors for synthesizing each column
        self._col_models: Dict[str, Dict[str, Any]] = {}  # fitted model for each column

        # For the first column—and for each numeric column with special values—
        # store the observed (real) distribution (filtered to numeric values only)
        self._stored_col_data: Dict[str, np.ndarray] = {}

    def fit_col(self, loader: Any, *args: Any, **kwargs: Any) -> "Syn_Seq":
        """
        Fit each column sequentially using metadata from the loader.
        
        In addition to reading user-defined (or pre-set) synthesis order, method mapping,
        and variable selection, this routine now scans the training data for any columns
        ending with "_cat" (which were injected by the preprocessor) and extracts the special
        values for their corresponding base columns.
        """
        info_dict = loader.info()
        training_data = loader.dataframe().copy()
        if training_data.empty:
            raise ValueError("No data => cannot fit Syn_Seq aggregator")

        # Set synthesis order, method mapping, and variable selection from loader info.
        self._syn_order = info_dict.get("syn_order", list(training_data.columns))
        self._method_map = info_dict.get("method", {})
        self._varsel = info_dict.get("variable_selection", {})

        # --- Extract special values from any _cat columns in the training data ---
        for col in training_data.columns:
            if col.endswith("_cat"):
                base_col = col[:-4]
                # Extract unique values from the _cat column, excluding only "NUMERIC"
                specials = training_data[col].unique()
                specials = [v for v in specials if v not in ["NUMERIC"]]
                if specials:
                    self.special_values[base_col] = specials

        # For auto-injected _cat columns, force aggregator "cart" and mirror variable selection.
        for col in self._syn_order:
            if col.endswith("_cat"):
                self._method_map[col] = "cart"
                base_col = col[:-4]
                if base_col in self._varsel:
                    self._varsel[col] = self._varsel[base_col]
                else:
                    idx = self._syn_order.index(col)
                    self._varsel[col] = self._syn_order[:idx]

        print("[INFO] Syn_Seq aggregator: fitting columns...")

        # (1) For the first column, store its real (non-null) distribution.
        first_col = self._syn_order[0]
        self._stored_col_data[first_col] = training_data[first_col].dropna().values

        # (2) For columns with special values, store only rows that are NOT special.
        for col, specials in self.special_values.items():
            if col not in training_data.columns:
                continue
            filtered = training_data[~training_data[col].isin(specials)]
            self._stored_col_data[col] = filtered[col].dropna().values

        print(f"Fitting '{first_col}' => stored distribution from real data. Done.")

        # (3) Fit a model for each subsequent column.
        np.random.seed(self.random_state)
        for i, col in enumerate(self._syn_order[1:], start=1):
            method_name = self._method_map.get(col, "cart")
            preds_list = self._varsel.get(col, self._syn_order[:i])
            y = training_data[col].values
            X = training_data[preds_list].values
            mask = (~pd.isna(y))
            # For numeric columns with special values, drop rows whose value is special.
            if col in self.special_values:
                specials = self.special_values[col]
                mask = mask & (~np.isin(y, specials))
            X_ = X[mask]
            y_ = y[mask]
            print(f"Fitting '{col}' with '{method_name}' ... ", end="", flush=True)
            try:
                self._col_models[col] = self._fit_single_col(method_name, X_, y_)
            except Exception as e:
                print(f"Error fitting column {col}: {e}. Falling back to swr.", end=" ")
                try:
                    self._col_models[col] = self._fit_single_col("swr", X, y)
                except Exception as e2:
                    print(f"Fallback swr also failed for {col}: {e2}. Storing None.", end=" ")
                    self._col_models[col] = None
            print("Done!")
        self._model_trained = True
        return self

    def _fit_single_col(self, method_name: str, X: np.ndarray, y: np.ndarray) -> Dict[str, Any]:
        """
        Fit a single column using the specified method.
        """
        fit_func, _ = METHOD_MAP[method_name]
        model = fit_func(y, X, random_state=self.random_state)
        return {"name": method_name, "fitted_model": model}

    def generate_col(self, count: int) -> pd.DataFrame:
        """
        Generate `count` rows sequentially.
        
        For columns with special values, the pre-generated _cat column (e.g. "capital-gain_cat")
        is used to decide which rows should have their value generated using the fitted model 
        (if the _cat cell equals "NUMERIC") and which rows should directly receive the special value.
        """
        if not self._model_trained:
            raise RuntimeError("Syn_Seq aggregator not yet fitted")
        if count <= 0:
            return pd.DataFrame(columns=self._syn_order)
        
        # Initialize a DataFrame with NaN values for all columns.
        gen_df = pd.DataFrame({col: [np.nan] * count for col in self._syn_order})
        
        # (1) Generate the first column using its stored real distribution.
        first_col = self._syn_order[0]
        if self._stored_col_data.get(first_col) is not None and len(self._stored_col_data[first_col]) > 0:
            gen_df[first_col] = np.random.choice(self._stored_col_data[first_col], size=count, replace=True)
        else:
            gen_df[first_col] = 0
        print(f"Generating '{first_col}' => done.")
        
        # (2) For each subsequent column, generate synthetic values.
        for col in self._syn_order[1:]:
            method_name = self._method_map.get(col, "cart")
            idx = self._syn_order.index(col)
            preds_list = self._varsel.get(col, self._syn_order[:idx])
            if col in self.special_values:
                # For columns with special values, rely on the pre-generated _cat column.
                cat_col = col + "_cat"
                if cat_col not in gen_df.columns:
                    raise RuntimeError(f"Expected categorical column {cat_col} not found in generated data.")
                # Rows with _cat == "NUMERIC" should be synthesized.
                is_numeric = gen_df[cat_col] == "NUMERIC"
                if is_numeric.sum() > 0:
                    Xsyn_numeric = gen_df.loc[is_numeric, preds_list].values
                    ysyn_numeric = self._generate_single_col(method_name, Xsyn_numeric, col)
                    gen_df.loc[is_numeric, col] = ysyn_numeric
                # For rows where _cat indicates a special value, assign that value directly.
                for special in self.special_values[col]:
                    is_special = gen_df[cat_col] == str(special)
                    gen_df.loc[is_special, col] = float(special)
            else:
                Xsyn = gen_df[preds_list].values
                ysyn = self._generate_single_col(method_name, Xsyn, col)
                gen_df[col] = ysyn
            print(f"Generating '{col}' => done.")
        return gen_df

    def _generate_single_col(self, method_name: str, Xsyn: np.ndarray, col: str) -> np.ndarray:
        """
        Generate synthetic values for a single column using the fitted model.
        If no model is available, falls back to sampling from the stored real distribution.
        """
        if col not in self._col_models or self._col_models[col] is None:
            if col in self._stored_col_data and len(self._stored_col_data[col]) > 0:
                return np.random.choice(self._stored_col_data[col], size=len(Xsyn), replace=True)
            else:
                return np.zeros(len(Xsyn))
        
        fit_info = self._col_models[col]
        _, generate_func = METHOD_MAP[fit_info["name"]]
        return generate_func(fit_info["fitted_model"], Xsyn)
